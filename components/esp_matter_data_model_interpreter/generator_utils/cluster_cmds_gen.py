# SPDX-FileCopyrightText: 2025 Espressif Systems (Shanghai) CO LTD
# SPDX-License-Identifier: Apache-2.0
import argparse
import os
import re
import xml.etree.ElementTree as ET

import yaml

static_text_register_command_cb_fn = """
esp_err_t register_command_cb(esp_matter::cluster_t *cluster, uint32_t cluster_id, uint32_t command_id, uint8_t flag)
{
    if (flag & esp_matter::COMMAND_FLAG_GENERATED) {
      esp_matter::command::create(cluster, command_id, esp_matter::COMMAND_FLAG_GENERATED, NULL);
      return ESP_OK;
    }

    esp_err_t result = ESP_FAIL;

    for (size_t i = 0; i < sizeof(cluster_cb_map) / sizeof(cluster_cb_map[0]); ++i) {
        const auto& cluster_cb = cluster_cb_map[i];
        if (cluster_id == cluster_cb.cluster_id) {
            if (flag & esp_matter::COMMAND_FLAG_ACCEPTED) {
                const CommandCallbackMap_t *cmd_map = *cluster_cb.accepted_cmds;
                if (cmd_map) {
                    for (; cmd_map->cmd_cb != nullptr; ++cmd_map) {
                        if (cmd_map->cmd_id == command_id) {
                            esp_matter::command::create(cluster, command_id, esp_matter::COMMAND_FLAG_ACCEPTED, cmd_map->cmd_cb);
                            result = ESP_OK;
                            break;
                        }
                    }
                }
                // Commands not present in the accepted command list, can be created with NULL callback
                // TODO: Check if any stricter checks are needed before creating commands
                if (result != ESP_OK) {
                    esp_matter::command::create(cluster, command_id, esp_matter::COMMAND_FLAG_ACCEPTED, NULL);
                    result = ESP_OK;
                }
                break;
            }
        }
    }
    return result;
}
"""
static_text_cluster_plugin_init_fn = """
esp_err_t cluster_plugin_init(esp_matter::cluster_t *cluster, uint32_t cluster_id)
{
    esp_err_t ret = ESP_FAIL;
    for (auto& cluster_cb : cluster_cb_map) {
        if (cluster_id == cluster_cb.cluster_id) {
            if (cluster_cb.init_fn) {
                esp_matter::cluster::set_plugin_server_init_callback(cluster, cluster_cb.init_fn);
            }
            esp_matter::cluster::add_function_list(cluster, cluster_cb.functions, cluster_cb.flag_mask);
            ret = ESP_OK;
        }
    }
    return ret;
}
"""
command_callback_impl_templ = """
static esp_err_t {}(const ConcreteCommandPath &command_path, TLVReader &tlv_data, void *opaque_ptr)
{{
    chip::app::Clusters::{}::Commands::{}::DecodableType command_data;
    CHIP_ERROR error = Decode(tlv_data, command_data);
    if (error == CHIP_NO_ERROR) {{
        emberAf{}Cluster{}Callback((CommandHandler *)opaque_ptr, command_path, command_data);
    }}
    return ESP_OK;
}}
"""

static_text_file_preface = """/*
 * SPDX-FileCopyrightText: 2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/* Generated by esp_matter_data_model_interpreter/generator_utils/cluster_cmds_gen.py (DO NOT EDIT!) */

#include <esp_err.h>
#include <esp_matter.h>
#include <esp_matter_core.h>

#include <app-common/zap-generated/callback.h>
#include <app/InteractionModelEngine.h>
#include <app/PluginApplicationCallbacks.h>

#include "cmd_c_routines.h"

using namespace chip::app::Clusters;
using chip::app::CommandHandler;
using chip::app::DataModel::Decode;
using chip::TLV::TLVReader;

#define CALL_ONCE(cb)                           \\
    [](){                                       \\
        static bool is_called = false;          \\
        if (!is_called) {                       \\
            cb();                               \\
            is_called = true;                   \\
        }                                       \\
    }

typedef struct {
    uint32_t cmd_id;
    esp_matter::command::callback_t cmd_cb;
} CommandCallbackMap_t;

typedef struct {
    uint32_t cluster_id;
    void (*init_fn)();
    const CommandCallbackMap_t (*accepted_cmds)[];
    uint32_t num_cmds;
    const EmberAfGenericClusterFunction * functions;
    uint8_t flag_mask;
} ClusterTableMap_t;
"""

cluster_table_map_instance_templ = """
    {{
        .cluster_id = {},
        .init_fn = {},
        .accepted_cmds = {},
        .num_cmds = {},
        .functions = {},
        .flag_mask = {},
    }},"""

ignore_clusters = [
    "Actions",
]

ignore_commands = {"Level Control": ["MoveToClosestFrequency"], "Smoke CO Alarm": ["SelfTestRequest"], "Bridged Device Basic Information": ["KeepActive"]}

macro_dependent_clusters = {
    "ICD Management": "CONFIG_ENABLE_ICD_SERVER",
}

macro_dependent_commands = {
    "ReviewFabricRestrictions": "CHIP_CONFIG_USE_ACCESS_RESTRICTIONS",
}


class Command:
    def __init__(self, name, name_alnum, id, cb, macro_dependency=""):
        self.name = name
        self.name_alnum = name_alnum
        self.id = id
        self.cb = cb
        self.macro_dependency=macro_dependency

class Cluster:
    def __init__(
        self, name, name_alnum, id, commands, init_fn, functions="nullptr", flag_mask="0", macro_dependency=""
    ):
        self.name = name
        self.name_alnum = name_alnum
        self.id = id
        self.commands = commands
        self.init_fn = init_fn
        self.functions = functions
        self.flag_mask = flag_mask
        self.macro_dependency = macro_dependency


def get_cluster_from_xml(cluster_xml_file, config_yaml_file) -> Cluster:
    cluster_dict = {}
    tree = ET.parse(cluster_xml_file)
    root = tree.getroot()

    with open(config_yaml_file, "r") as f:
        yaml_config_data = yaml.safe_load(f)

    # Getting cluster name
    cluster = root.find("cluster")
    if cluster is not None:
        cluster_name = cluster.find("name").text
        # Cluster name eventually used in the function and structure names in the code
        cluster_name_alnum = "".join(
            word[0].upper() + (word[1:].lower() if word[1:].isupper() else word[1:])
            for word in re.split(r"[ \_\-\\/]", cluster_name.strip())
        )
        # Getting cluster ID
        cluster_id = cluster.find("code").text

        # Getting cluster commands
        commands = []
        plugin_init_cb = "nullptr"
        if (
            cluster_name not in yaml_config_data["CommandHandlerInterfaceOnlyClusters"]
            and cluster.get("apiMaturity") not in ["provisional", "internal"]
            and cluster_name not in ignore_clusters
            and cluster.find("command") is not None
        ):
            for command in cluster.findall("command"):
                if (
                    command.get("source") == "client"
                    and command.get("apiMaturity") not in ["provisional", "internal"]
                    and (
                        cluster_name not in ignore_commands or command.get("name") not in ignore_commands[cluster_name]
                    )
                ):
                    command_id = command.get("code")
                    command_name = command.get("name")
                    command_name_alnum = "".join(char for char in command_name if char.isalnum())
                    command_cb = f"{cluster_name_alnum}{command_name_alnum}Callback"
                    macro_dependency = ""
                    if command_name in macro_dependent_commands:
                        macro_dependency=macro_dependent_commands[command_name]
                    commands.append(Command(command_name, command_name_alnum, command_id, command_cb, macro_dependency=macro_dependency))
            plugin_init_cb = f"CALL_ONCE(Matter{cluster_name_alnum}PluginServerInitCallback)"

        macro_dependency = ""
        if cluster_name in macro_dependent_clusters.keys():
            macro_dependency = macro_dependent_clusters[cluster_name]
        return Cluster(
            cluster_name, cluster_name_alnum, cluster_id, commands, plugin_init_cb, macro_dependency=macro_dependency
        )
    else:
        return None


def update_cluster_flagmask_and_ember_fn_array(cluster, config_yaml_file):
    # Getting flag_mask
    with open(config_yaml_file, "r") as f:
        yaml_config_data = yaml.safe_load(f)

    functions = {
        "ClustersWithInitFunctions": ["esp_matter::CLUSTER_FLAG_INIT_FUNCTION", "ClusterServerInitCallback"],
        "ClustersWithAttributeChangedFunctions": [
            "esp_matter::CLUSTER_FLAG_ATTRIBUTE_CHANGED_FUNCTION",
            "ClusterServerAttributeChangedCallback",
        ],
        "ClustersWithShutdownFunctions": [
            "esp_matter::CLUSTER_FLAG_SHUTDOWN_FUNCTION",
            "ClusterServerShutdownCallback",
        ],
        "ClustersWithPreAttributeChangeFunctions": [
            "esp_matter::CLUSTER_FLAG_PRE_ATTRIBUTE_CHANGED_FUNCTION",
            "ClusterServerPreAttributeChangedCallback",
        ],
    }

    if cluster.name not in yaml_config_data["CommandHandlerInterfaceOnlyClusters"]:
        cluster.flag_mask = " | ".join(functions[fn][0] for fn in functions if cluster.name in yaml_config_data[fn])
        cluster.ember_func_array = "\n\t".join(
            f"(EmberAfGenericClusterFunction) {'emberAf' if fn == 'ClustersWithInitFunctions' else 'Matter'}{cluster.name_alnum}{functions[fn][1]},"
            for fn in functions
            if cluster.name in yaml_config_data[fn]
        )


def generate_callback_functions(clusters, file):
    for cluster in clusters:
        if cluster.macro_dependency and cluster.commands:
            file.write(f"#if {cluster.macro_dependency}")
        for command in cluster.commands:
            if command.macro_dependency:
                file.write(f"#if {command.macro_dependency}")
            file.write(
                command_callback_impl_templ.format(
                    command.cb, cluster.name_alnum, command.name_alnum, cluster.name_alnum, command.name_alnum
                )
            )
            if command.macro_dependency:
                file.write(f"#endif /* {command.macro_dependency} */")
        if cluster.macro_dependency and cluster.commands:
            file.write(f"#endif /* {cluster.macro_dependency} */")


def generate_command_array(clusters, file):
    for cluster in clusters:
        command_callback_map = ""
        if cluster.commands:
            if cluster.macro_dependency:
                command_callback_map += f"#if {cluster.macro_dependency}\n"
            command_callback_map += f"const CommandCallbackMap_t {cluster.name_alnum}AcceptedCommands[] = {{\n"
            for command in cluster.commands:
                if command.macro_dependency:
                    command_callback_map += f"#if {command.macro_dependency}\n"
                command_callback_map += f"\t{{ {command.id}, {command.cb} }},\n"
                if command.macro_dependency:
                    command_callback_map += f"#endif /* {command.macro_dependency} */\n"
            command_callback_map += "};\n"
            if cluster.macro_dependency:
                command_callback_map += f"#endif /* {cluster.macro_dependency} */\n"
            file.write(command_callback_map)


def generate_cluster_static_arrays(clusters, file):
    for cluster in clusters:
        if hasattr(cluster, "ember_func_array") and cluster.ember_func_array:
            ember_func_array = f"const EmberAfGenericClusterFunction chipFuncArray{cluster.name_alnum}Server[] = {{\n\t"
            ember_func_array += cluster.ember_func_array
            ember_func_array += "\n};\n"
            file.write(ember_func_array)


def generate_cluster_struct_arrays(clusters, file):
    file.write("const ClusterTableMap_t cluster_cb_map[] = {")
    for cluster in clusters:
        if cluster.commands:
            commands = f"&{cluster.name_alnum}AcceptedCommands"
            num_cmds = f"sizeof({cluster.name_alnum}AcceptedCommands)"
        else:
            commands = "nullptr"
            num_cmds = "0"

        if hasattr(cluster, "ember_func_array") and cluster.ember_func_array:
            functions = f"chipFuncArray{cluster.name_alnum}Server"
        else:
            functions = "nullptr"
            mask = "0"

        if cluster.macro_dependency:
            file.write(f"\n#if {cluster.macro_dependency}")
        file.write(cluster_table_map_instance_templ.format(cluster.id, cluster.init_fn, commands, num_cmds, functions, mask))
        if cluster.macro_dependency:
            file.write(f"\n#endif /* {cluster.macro_dependency} */")
    file.write("\n};\n")


xml_dir = os.path.expandvars(
    os.path.join(
        "$ESP_MATTER_PATH",
        "connectedhomeip",
        "connectedhomeip",
        "src",
        "app",
        "zap-templates",
        "zcl",
        "data-model",
        "chip",
    )
)
config_yaml = os.path.expandvars(
    os.path.join(
        "$ESP_MATTER_PATH",
        "connectedhomeip",
        "connectedhomeip",
        "src",
        "app",
        "common",
        "templates",
        "config-data.yaml",
    )
)

clusters = []
for filename in os.listdir(xml_dir):
    if filename.endswith(".xml"):
        cluster = get_cluster_from_xml(os.path.join(xml_dir, filename), config_yaml)
        if cluster:
            update_cluster_flagmask_and_ember_fn_array(cluster, config_yaml)
            clusters.append(cluster)

parser = argparse.ArgumentParser(description="Generate Matter command routines file.")
parser.add_argument("-o", "--output_file", required=True, help="File path where the output will be written")
args = parser.parse_args()

with open(args.output_file, "w") as file:
    file.write(static_text_file_preface)
    generate_callback_functions(clusters, file)
    generate_command_array(clusters, file)
    generate_cluster_static_arrays(clusters, file)
    generate_cluster_struct_arrays(clusters, file)
    file.write(static_text_register_command_cb_fn)
    file.write(static_text_cluster_plugin_init_fn)
